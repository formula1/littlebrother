
<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body style="background-color: #030302">
<div style="display:none">
  <img id="orange" src="images/orange.jpg">
  <img id="green" src="images/green.jpg">
  <img id="purple" src="images/purple.jpg">
  <img id="pink" src="images/pink.jpg">
  <img id="blue" src="images/blue.jpg">
  <img id="blank" src="images/blank.jpg">
</div>
<div class="header">
  <div class="relative wrapper">
    <!-- <img id="header" src="images/mock header.png"> -->
    <img id="header" src="images/header.png">
    <div class="score">
      <div> Score : <span id="score">0</span></div>
      <div> Level : <span id="level">1</span></div>
    </div>

    <div class="highscore">
      <div>High Score : <span id="highscore">CHEEEESE</span></div>
      <div>Highest Level : <span id="highestlevel">1</span></div>
    </div>
  </div>
</div>
  
</div> 
<div >
<canvas id="gameCanvas" width="612" height="600"></canvas>
</div>
</body>
<script>
  var mouseX = 0;
  var mouseY = 0;
  var selectedIdx = -1;
  var tileOverIdx = -1;
  var matches = [];
  var scoreValue = 0;
  var highScoreValue = 0;
  var score = document.getElementById("score");
  var highScore = document.getElementById("highscore")
  var noMatchSound = new Audio('sounds/no_match.mp3');
  var yesMatchSound = new Audio('sounds/yes_match.mp3');
  var loseSound = new Audio('sounds/lose_sound.mp3');
  
  const TILE_W = 75;
  const TILE_H = 75;
  const TILE_GAP = 1;
  const TILE_COLS = 8;
  const TILE_ROWS = 8;

  var tileGrid = []

  var tiles = {}
  var tilesCount = 0;
  
  var img = {}
  const ORANGE = 0;
  img[ORANGE] =document.getElementById("orange");
  const GREEN = 1;
  img[GREEN] =document.getElementById("green");
  const BLUE = 2;
  img[BLUE] =document.getElementById("blue");
  const PURPLE = 3;
  img[PURPLE] =document.getElementById("purple");
  const PINK = 4;
  img[PINK] =document.getElementById("pink");
  const BLANK = 5;
  img[BLANK] =document.getElementById("blank");
  
  function initInput() {
    document.addEventListener("mousemove", mousemoved);
    document.addEventListener("mousedown", mouseclicked);
  }
  
  function saveData() {
    if(typeof(Storage) != "undefined") {
            localStorage.localHighScore = highScoreValue;
        } else {
            console.log("web storage not supported");
    }
  }
  
  function loadSavedData() {
    if (typeof(Storage) != "undefined") {
      if (localStorage.localHighScore) {
        highScoreValue = Number(localStorage.localHighScore);
        highScore.innerHTML = highScoreValue;
      } else {
        highScoreValue = 0;
      }
    } else {
      console.log("web storage not supported");
    }
  }

  function updateScore() {
    score.innerHTML = scoreValue;

    if (scoreValue > highScoreValue) {
      highScoreValue = scoreValue;
      highScore.innerHTML = highScoreValue;
      saveData();
    }
  }
  
  function gravity() {
    for (var c = 0; c < TILE_COLS; c++){
      for (var r = TILE_ROWS - 1; r >= 0; r--){
        var idxHere = tileCoordToIndex(c, r);
        var tileId = tileGrid[idxHere];
        if(tileId === undefined)
          new_tile(r, c)
        if(!tiles[tileId] || tiles[tileId].Type == BLANK){
          if(r > 0){
            var idxAbove = tileCoordToIndex(c, r-1);
            tileGrid[idxHere] = tileGrid[idxAbove];
            tileGrid[idxAbove] = BLANK;
          } else {
            new_tile(r, c)
            //tileGrid[idxHere] = Math.floor(Math.random() * 5);
          }
        }
      } // end rows
    } // end columns
  }  // end gravity
  
  function match3Checker(){
    var lastSeen = -1;
    var reps = 0;
    for (var r = 0; r < TILE_ROWS; r++){
      lastSeen = -1;
      for (var c = 0; c < TILE_COLS; c++){
        var tile = getTile(r, c);
        if(isFalling(tile)){
          lastSeen =-1
          reps = 0
          break
        }

        if (tile.Type == lastSeen && tile.Type != BLANK){
          reps++;
          if (reps >= 2){
            for (var s = 0; s < 3; s++){
            //   tileGrid[tileCoordToIndex(c-s, r)] = BLANK;
              console.log("tileidx = " + tileCoordToIndex(c-s, r))
              var tileLeftEdgeX = (c-s) * TILE_W ;
              var tileTopEdgeY = r * TILE_H;
              outlineRect(tileLeftEdgeX, tileTopEdgeY, TILE_W - TILE_GAP, TILE_H - TILE_GAP, 'red' );
              matches.push(getTile(r, c-s));
            }
            console.log("Matched h! " + tile.Type);
            ++scoreValue            
            updateScore();
          }
        } else {
          lastSeen = tile.Type;
          reps = 0;
        } 
      } // end of c
    } // end of r
    lastSeen = -1;
    reps = 0;

    for (var c = 0; c < TILE_COLS; c++){
      lastSeen = -1;
      for (var r = 0; r < TILE_ROWS; r++){
        var tile = getTile(r, c);
        if(isFalling(tile)){
          lastSeen =-1
          reps = 0
          break
        }
          
        if (tile.Type == lastSeen && tile.Type != BLANK){
          reps++;
          if (reps >= 2){
            for (var s = 0; s < 3; s++){
              var tileLeftEdgeX = c * TILE_W ;
              var tileTopEdgeY = (r -s) * TILE_H;
              outlineRect(tileLeftEdgeX, tileTopEdgeY, TILE_W - TILE_GAP, TILE_H - TILE_GAP, 'red' );
              console.log("tileidx = " + tileCoordToIndex(c, r-s))
              matches.push(getTile(r-s, c));
            }
            console.log("Matched v! " + tile.Type);
            ++scoreValue
            score.innerHTML = scoreValue;
            updateScore();
          }
        } else {
          lastSeen = tile.Type;
          reps = 0;
        } 

      } // end of c
    } // end of r
    
  } // end of function
  function isFalling(tile){
    for(var r = tile.row; r < TILE_ROWS; r++){
      if(getTile(r, tile.column).Type == BLANK){
        return true;
      }
    }
    return false;
  }

  function removeClusters() {
    for (var i = 0; i < matches.length; i++){
      matches[i].Type = BLANK;
    }
    matches = [];
    drawEverything();
  }

  function getTile(row, column){
    gridId = tileCoordToIndex(column, row);
    tileId = tileGrid[gridId];
    var temptile = tiles[tileId]
    if(!temptile)
      debugger;
    return temptile;
  }



  function new_tile(row, column){
    ++tilesCount
    tiles[tilesCount] = {
      id: tilesCount,
      Type: Math.floor(Math.random() * 5),
      row: row, 
      column: column, 
      y: 0,
    }
    id = tileCoordToIndex(column, row);
    tileGrid[id] = tilesCount
  }

  
  function idxToCR(idx){
    var col = idx % TILE_COLS;
    var row = Math.floor(idx/TILE_COLS);
    return {"c": col, "r": row};
  }
  
  function swap (tile1, tile2) {
    tileGrid[selectedIdx] = tile1;
    tileGrid[tileOverIdx] = tile2;
  }

  function mouseclicked(evt) {
    if(tileOverIdx < 0 || tileOverIdx >= tileGrid.length) { // invalid or off board
      return;
    }

    if(selectedIdx != -1) {
    var tileOverPos = idxToCR(tileOverIdx);
    var selectedPos = idxToCR(selectedIdx);
    var diffC = Math.abs(tileOverPos.c - selectedPos.c);
    var diffR = Math.abs(tileOverPos.r - selectedPos.r)
    if ((diffC < 2 && diffR == 0) || (diffC == 0 && diffR < 2)){
      swap(tileGrid[tileOverIdx], tileGrid[selectedIdx]);
      match3Checker();
      if (matches.length == 0){
        noMatchSound.play();
        swap(tileGrid[tileOverIdx], tileGrid[selectedIdx]);
      } else {
        yesMatchSound.play();
      }
    }
      selectedIdx = -1; // forget selection
    } else {
      selectedIdx = tileOverIdx;
    }
  }

  function mousemoved(evt) {
    var rect = canvas.getBoundingClientRect();
    var root = document.documentElement;

    // account for the margins, canvas position on page, scroll amount, etc.
    mouseX = evt.clientX - rect.left - root.scrollLeft;
    // mouseX = Math.round((evt.clientX - rect.left - root.scrollLeft)/(rect.right - rect.left) * canvas.width);
    mouseY = evt.clientY - rect.top - root.scrollTop;
    // mouseY = Math.round((evt.clientY - rect.top - root.scrollTop)/(rect.bottom - rect.top) * canvas.height);
    
    //if mouse is outside canvas, don't highlight
    if(mouseX < 0 || mouseX > canvas.width - 15)
      return

    var tileOverCol = Math.floor(mouseX / TILE_W);
    var tileOverRow = Math.floor(mouseY / TILE_H);    
    tileOverIdx = tileCoordToIndex(tileOverCol,tileOverRow);
  }

  var canvas, canvasContext;
  
  function tileCoordToIndex(tileCol, tileRow) {
    return (tileCol + TILE_COLS*tileRow);
  }
  
  window.onload = function() {
    canvas = document.getElementById('gameCanvas');
    canvasContext = canvas.getContext('2d');
    loadSavedData();
    
    initInput();
    for (var c = 0; c < TILE_COLS; c++){
      for (var r = TILE_ROWS - 1; r >= 0; r--){
        var idxHere = tileCoordToIndex(c, r);
        var tileId = tileGrid[idxHere];
        if(tileId === undefined)
          new_tile(r, c)
      }
    }
    // these next few lines set up our game logic and render to happen 60 times per second
    var framesPerSecond = 4;
    setInterval(function() {
      gravity();
      drawEverything();
      match3Checker();
      removeClusters();
      
    }, 1000/framesPerSecond);

    canvasContext.font="12px Arial";
  }
  
  function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
    canvasContext.fillStyle = fillColor;
    canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
  }

  function outlineRect(topLeftX, topLeftY, boxWidth, boxHeight, lineColor) {
    canvasContext.beginPath();
    canvasContext.strokeStyle = lineColor;
    canvasContext.lineWidth = "3";
    canvasContext.rect(topLeftX, topLeftY, boxWidth, boxHeight);
    canvasContext.stroke();
  }
  
  function drawTiles() {
    for(var eachCol=0; eachCol<TILE_COLS; eachCol++) {
      for(var eachRow=0; eachRow<TILE_ROWS; eachRow++) {
        var tileLeftEdgeX = eachCol * TILE_W ;
        var tileTopEdgeY = eachRow * TILE_H;


        var idxHere = tileCoordToIndex(eachCol,eachRow);
        var tileId = tileGrid[idxHere];
        var pieceHere = tiles[tileId];

        if(pieceHere.y != tileTopEdgeY + 11){
          pieceHere.y += 10
        }

        if(pieceHere.y > tileTopEdgeY + 11){
          pieceHere.y = tileTopEdgeY + 11;
        }

        canvasContext.drawImage(img[pieceHere.Type], tileLeftEdgeX + 11, pieceHere.y);
        canvasContext.fillStyle = 'white';
        canvasContext.fillText(eachRow + ", " + eachCol , tileLeftEdgeX+TILE_W/2, tileTopEdgeY+TILE_H);


        // not a super efficient way to do this, but c'mon, it's a boardgame!
        // based on exercises you've already done you could optimize this :)
        if(tileOverIdx == idxHere) {
          outlineRect(tileLeftEdgeX, tileTopEdgeY,
                   TILE_W - TILE_GAP, TILE_H - TILE_GAP, 'green' );
        }
        if(selectedIdx == idxHere) {
          // cutting extra margin from each edge so it won't overlap mouseover tile
          outlineRect(tileLeftEdgeX+3, tileTopEdgeY+3,
                   TILE_W - TILE_GAP-6, TILE_H - TILE_GAP-6, 'yellow' );
        }
      } // end of for eachRow
    } // end of for eachCol
  } // end of drawTiles()
  
  function drawEverything() {
    colorRect(0, 0, canvas.width, canvas.height, 'black');

    canvasContext.textAlign="center";
    drawTiles();
    
    canvasContext.textAlign="left";
    canvasContext.fillStyle = 'white';
    var rightAreaX = TILE_W*TILE_COLS;
    var lineSkip = 15;
    var lineY = 20;
  }
</script>

</body>
</html>